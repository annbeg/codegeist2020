import { Forge, ForgeElement, RenderState, JsxTextProps, FunctionElement, PrimitiveElement } from './types';
interface Hook {
    type: 'async' | 'action';
    value: any;
}
export declare type AuxFiber<P = {
    [p: string]: any;
}> = FunctionFiber<P> | PrimitiveFiber<P> | TextFiber;
export interface PrimitiveFiber<P = {
    [p: string]: any;
}> {
    type: 'primitive';
    children: AuxFiber[];
    element: PrimitiveElement<P>;
    key: string;
}
export interface FunctionFiber<P = {
    [p: string]: any;
}> {
    type: 'function';
    children: AuxFiber[];
    element: FunctionElement<P>;
    hooks: Hook[];
    currentHookIndex: number;
    key: string;
}
export interface TextFiber {
    type: 'text';
    children: AuxFiber[];
    text: string;
}
export declare const isTextElement: (element: ForgeElement<any>) => element is ForgeElement<JsxTextProps>;
export declare const processAuxElement: (element: ForgeElement<Record<string, any>>) => Promise<AuxFiber<{
    [p: string]: any;
}>>;
export declare const getAdfFromFiber: (processMarkdown?: boolean) => (fiber: AuxFiber<{
    [p: string]: any;
}>) => {
    [k: string]: any;
}[];
export declare const mergeConsecutiveTextFibers: (fibers: AuxFiber<{
    [p: string]: any;
}>[], currentFiber: AuxFiber<{
    [p: string]: any;
}>) => AuxFiber<{
    [p: string]: any;
}>[];
export declare const getAuxFromFiber: (fiber: AuxFiber<{
    [p: string]: any;
}>) => Forge[];
export declare const getStateFromFiber: <P>(fiber: AuxFiber<P>) => RenderState;
export {};
