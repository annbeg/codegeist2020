import markdownit from 'markdown-it';
import { MarkdownParser } from 'prosemirror-markdown';
import { defaultSchema } from '@atlaskit/adf-schema';
import { JSONTransformer } from '@atlaskit/editor-json-transformer';
const mdParser = markdownit('zero', { linkify: true, breaks: true }).enable([
    'emphasis',
    'strikethrough',
    'newline',
    'link',
    'linkify',
    'backticks',
]);
const defaultParagraphRule = mdParser.block.ruler.getRules('')[0];
// wrap original paragraph rule to preserve surrounding whitespace
const newParagraphRule = (state, startLine) => {
    const nextLine = state.lineMax;
    const originalContent = state.getLines(startLine, nextLine, state.blkIndent, false);
    defaultParagraphRule(state, startLine);
    // defaultParagraphRule always pushes 3 tokens on (start paragraph, inline content, end paragraph)
    const contentToken = state.tokens[state.tokens.length - 2];
    if (contentToken && contentToken.type === 'inline') {
        contentToken.content = originalContent;
    }
    return true;
};
const auxMarkdownParser = new MarkdownParser(defaultSchema, mdParser, {
    paragraph: { block: 'paragraph' },
    softbreak: { node: 'hardBreak' },
    hardbreak: { node: 'hardBreak' },
    strong: { mark: 'strong' },
    em: { mark: 'em' },
    s: { mark: 'strike' },
    // eslint-disable-next-line @typescript-eslint/camelcase
    code_inline: { mark: 'code' },
    link: {
        mark: 'link',
        getAttrs: (tok) => ({
            href: tok.attrGet('href'),
            title: tok.attrGet('title') || null,
        }),
    },
});
const jsonTransformer = new JSONTransformer();
export const md2Adf = (md, overrideParagraphRule = false) => {
    if (overrideParagraphRule) {
        mdParser.block.ruler.at('paragraph', newParagraphRule);
    }
    else {
        mdParser.block.ruler.at('paragraph', defaultParagraphRule);
    }
    const doc = auxMarkdownParser.parse(md);
    return jsonTransformer.encode(doc);
};
