import { isForgeElement, isEventEffect, } from './types';
import { Macro } from './components';
import reconcilerState from './reconcilerState';
import { md2Adf } from './markdown';
export const isTextElement = (element) => element.type === 'Text';
const flatMap = (fn, items) => items.reduce((bs, a) => bs.concat(fn(a)), []);
const asyncMap = async (fn, items) => {
    const results = [];
    for (const x of items) {
        const result = await fn(x);
        results.push(result);
    }
    return results;
};
const _processAuxElement = (getUniqueName, path) => async (element) => {
    if (typeof element === 'string' || typeof element === 'number') {
        return {
            type: 'text',
            text: element.toString(),
            children: [],
        };
    }
    else if (typeof element.type === 'string') {
        const key = getUniqueName(`${element.props.__auxId || element.type}`);
        const currentEffect = reconcilerState.currentEffect;
        if (currentEffect &&
            isEventEffect(currentEffect) &&
            key === currentEffect.handler.componentKey) {
            reconcilerState.enableSideEffectsQueue();
            await element.props[currentEffect.handler.prop](...currentEffect.args);
            reconcilerState.disableSideEffectsQueue();
        }
        return {
            type: 'primitive',
            element: {
                ...element,
                type: element.type,
            },
            key,
            children: await asyncMap(_processAuxElement(getUniqueName, [...path, element.type]), element.props.children.filter(isForgeElement)),
        };
    }
    else if (typeof element.type === 'function') {
        // function component
        const { __auxId, ...props } = element.props;
        if (element.type === Macro) {
            if (!reconcilerState.config) {
                // set default config if no config exists
                reconcilerState.config = element.props.defaultConfig;
            }
        }
        reconcilerState.wipFiber = {
            type: 'function',
            element: {
                ...element,
                type: element.type,
            },
            key: getUniqueName(`${__auxId || element.type.name}`),
            hooks: [],
            currentHookIndex: 0,
            children: [],
        };
        let children = undefined;
        while (children === undefined) {
            try {
                children = element.type(props);
            }
            catch (e) {
                if (e instanceof Promise) {
                    await e;
                }
                else {
                    throw e;
                }
            }
        }
        const fiber = {
            ...reconcilerState.wipFiber,
            currentHookIndex: 0,
        };
        reconcilerState.clearWipFiber();
        return {
            ...fiber,
            children: await asyncMap(_processAuxElement(getUniqueName, [...path, element.type.name]), children ? [children] : []),
        };
    }
    throw new Error(`Unexpected child type: ${Array.isArray(element) ? 'Array' : element.type || typeof element}. Valid children are @forge/ui components, function components, and strings.\nError occurred in ${path.length > 0 ? path[path.length - 1] : 'render'}${path.length > 1 ? ':\n\tin ' : '.'}${path
        .reverse()
        .slice(1)
        .join('\n\tin ')}`);
};
export const processAuxElement = async (element) => {
    const visitedElements = {};
    const getUniqueName = name => {
        if (typeof visitedElements[name] === 'undefined') {
            visitedElements[name] = 0;
        }
        else {
            visitedElements[name]++;
        }
        return `${name}.${visitedElements[name]}`;
    };
    return _processAuxElement(getUniqueName, [])(element);
};
const overrideHandlers = (type, key) => {
    if (type === 'Button') {
        return {
            onClick: {
                componentKey: key,
                prop: 'onClick',
            },
        };
    }
    else if (type === 'Form') {
        return {
            onSubmit: {
                componentKey: key,
                prop: 'onSubmit',
            },
        };
    }
    else if (type === 'ModalDialog') {
        return {
            onClose: {
                componentKey: key,
                prop: 'onClose',
            },
        };
    }
    return {};
};
const getColorFromAppearance = (appearance) => {
    switch (appearance) {
        case 'inprogress':
            return 'blue';
        case 'moved':
            return 'yellow';
        case 'new':
            return 'purple';
        case 'removed':
            return 'red';
        case 'success':
            return 'green';
        default:
            return 'grey';
    }
};
export const getAdfFromFiber = (processMarkdown = true) => {
    const _getAdfFromFiber = (fiber) => {
        if (fiber.type === 'text') {
            if (processMarkdown) {
                const doc = md2Adf(fiber.text || '', true);
                // doc.content will be empty when processing just whitespace strings
                if (doc.content[0]) {
                    return doc.content[0].content;
                }
            }
            return [
                {
                    type: 'text',
                    text: fiber.text,
                },
            ];
        }
        else if (fiber.type === 'primitive') {
            const { type, props } = fiber.element;
            if (type === 'Lozenge') {
                return [
                    {
                        type: 'status',
                        attrs: {
                            text: props.text,
                            color: getColorFromAppearance(props.appearance),
                        },
                    },
                ];
            }
            else if (type === 'DateLozenge') {
                return [
                    {
                        type: 'date',
                        attrs: {
                            timestamp: props.value,
                        },
                    },
                ];
            }
            else if (type === 'Fragment') {
                return flatMap(_getAdfFromFiber, fiber.children);
            }
            return [];
        }
        return flatMap(_getAdfFromFiber, fiber.children);
    };
    return _getAdfFromFiber;
};
/*
JSX splits up interpolated strings so we need to merge consecutive strings back together
in order to allow markdown to transform the text properly
*/
export const mergeConsecutiveTextFibers = (fibers, currentFiber) => {
    const previousFiber = fibers[fibers.length - 1];
    if (currentFiber.type === 'text' &&
        previousFiber &&
        previousFiber.type === 'text') {
        const mergedTextFiber = {
            ...previousFiber,
            text: previousFiber.text + currentFiber.text,
        };
        return fibers.slice(0, fibers.length - 1).concat(mergedTextFiber);
    }
    return fibers.concat(currentFiber);
};
export const getAuxFromFiber = (fiber) => {
    /** Transform markdown to ADF
     * @see https://product-fabric.atlassian.net/wiki/spaces/AUX/pages/959122884/AUX+RFC-7+Text+rendering+pipeline
     */
    if (fiber.type === 'primitive') {
        const { element, key, children } = fiber;
        if (element.type === 'Text') {
            let props;
            const { format } = element.props;
            const processMarkdown = format === undefined || format === 'markdown';
            try {
                if (children.length > 0) {
                    props = {
                        format: 'adf',
                        content: {
                            type: 'doc',
                            version: 1,
                            content: [
                                {
                                    type: 'paragraph',
                                    content: children
                                        .reduce(mergeConsecutiveTextFibers, [])
                                        .reduce((content, child) => content.concat(getAdfFromFiber(processMarkdown)(child)), []),
                                },
                            ],
                        },
                    };
                }
                else {
                    if (processMarkdown) {
                        props = {
                            format: 'adf',
                            content: md2Adf(element.props.content || ''),
                        };
                    }
                    else {
                        props = {
                            format: 'plaintext',
                            content: element.props.content,
                        };
                    }
                }
            }
            catch (err) {
                props = {
                    format: 'plaintext',
                    content: `Error parsing markdown\n${err}`,
                };
            }
            return [
                {
                    type: element.type,
                    children: [],
                    key,
                    props,
                },
            ];
        }
        else if (element.type === 'Fragment') {
            return flatMap(getAuxFromFiber, children);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { children: _, ...props } = element.props;
        return [
            {
                children: flatMap(getAuxFromFiber, children),
                key,
                props: {
                    ...props,
                    ...overrideHandlers(element.type, fiber.key),
                },
                type: element.type,
            },
        ];
    }
    else if (fiber.type === 'text') {
        throw new Error('String or number elements must be used inside Text components');
    }
    // function fiber
    return flatMap(getAuxFromFiber, fiber.children);
};
export const getStateFromFiber = (fiber) => {
    let state = {};
    if (fiber.type === 'function' &&
        fiber.hooks.some(hook => hook.type === 'action')) {
        state = {
            [fiber.key]: fiber.hooks.reduce((map, hook, hookIndex) => {
                if (hook.type === 'action') {
                    map[hookIndex] = hook.value;
                }
                return map;
            }, {}),
        };
    }
    fiber.children.forEach(child => {
        state = { ...state, ...getStateFromFiber(child) };
    });
    return state;
};
